\section{Algoritmo de contagem}
Diferentemente dos algoritmos outrora apresentados, o algoritmo em tópico possui uma complexidade linear, isto é, o tempo levado para ordernar uma lista, ao contrário dos apresentados, não cresce de maneira quadrática. 

Em relação ao uso de memória, contudo, há uma grande desvantagem no algoritmo, uma vez que a lista auxiliar utilizada possuirá $\max{lista}-\min{lista} $ elementos; ou seja, caso o maior elemento seja 5000 e o menor 1000, a lista auxiliar possuirá de 4000 elementos.

Dessa forma, o algoritmo possui um melhor proveito se utilizado para listas com pouca variação de tamanho entre os seus elementos.

\subsection{Exemplo}
Seja $M$ a lista \[4,2,3,1,4,2,2,0\] Como a diferença entre o maior e o menor é elemento é 4, a lista auxiliar $Aux$ será de tamanho 4.
Assim, a lista auxiliar será da seguinte forma (assumindo que o primeiro elemento é $Aux[0]$): o primeiro elemento terá o valor igual à quantidade de zeros na lista original, que é 1, o segundo elemento de $Aux$, por outro lado, terá o mesmo valor 3, uma vez que há três elemento 2 na lista original. Essa lógica seguirá até chegar no último elemento.
Assim, de início, a lista $Aux$ será [1,1,3,1,2].

Após isso, começará a modificação da lista original: será adicionados a $n$ vezes o elemento referente ao índice da lista auxiliar, ou seja, como $Aux[0]$ é igual a 1, será adicionado um zero á lista original (adicionando pela direita um ao lado do outro). Em $Aux[2]$, por exemplo, o elemento é 3, assim, será adicionado o elemento 2 três vezes seguidas à lista $M$.

Segue, a seguir, os valores de \code{Aux} a cada modificação e, logo abaixo, os valores de $M$:
\begin{lstlisting}
[0, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 1, 0, 0, 0]
[1, 1, 3, 0, 0]
[1, 1, 3, 1, 0]
[1, 1, 3, 1, 2]
\end{lstlisting}

\begin{lstlisting}
    [4, 2, 3, 1, 4, 2, 2, 0]
    [0, 2, 3, 1, 4, 2, 2, 0]
    [0, 1, 3, 1, 4, 2, 2, 0]
    [0, 1, 2, 1, 4, 2, 2, 0]
    [0, 1, 2, 2, 4, 2, 2, 0]
    [0, 1, 2, 2, 2, 2, 2, 0]
    [0, 1, 2, 2, 2, 3, 2, 0]
    [0, 1, 2, 2, 2, 3, 4, 0]
    [0, 1, 2, 2, 2, 3, 4, 4] 
\end{lstlisting}

Notoriamente, a lista, durante as mudanças intermediárias, não possui todos os valores iniciais, isto é, alguns dos elementos (como o 4) deixam de existir em alguma etapa e voltam a aparecer somente depois.


\subsection{Implementação}
Segue a implementação em Python

\begin{lstlisting}
def counting(V, n):
    max_element = max(V)
    hist_list = [0 for _ in range(max_element + 1)]
    for i in range(max_element + 1):
        hist_list[i] = count_element_in_array(i, V)
    index = 0
    for i in range(max_element + 1):
        for _ in range(hist_list[i]):
            V[index] = i
            index += 1
\end{lstlisting}
Como pode-se perceber, o algoritmo de contagem, assim como os outros, possui duas malhas de repetição. Contudo, em vez da segunda estar dentro da terceira, uma ocorre após a outra.
Apesar disso, uma singularidade desse algoritmo é que, ao contrário dos outros, a quantidade de itinerações na primeira malha de repetição depende do tamanho do maior elemento (pensando apenas na implementação com números positivos), tornando-o eficaz para listas grandes mas com elementos menores.
Adicionalmente, este algoritmo não ordena os elementos por comparação...

\subsection{Quantidade de comparações}
Diferentemente de todos os algoritmos outrora citados, este não realiza qualquer comparação.