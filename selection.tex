\section{Algoritmo de seleção}
O algoritmo de Seleção é um algoritmo de ordenação no qual, a cada itineração, o menor elemento da lista é garantido estar na posição correta. Ou seja, na primeira itineração, assegura-se que o menor elemento ficará na primeira posição da lista, na segunda itineração, o segundo elemento, e assim por diante. 

Acerca do seu desempenho, o algoritmo em questão possui um "desempenho" quadrático, isto é, para $n$ elementops da lista, o algoritmo realizará $\frac{n(n+1)}{2}$ comparações a fim de ordernar totalmente a lista. Uma observação pertinente é que a quantidade de comparações a ser feita independe da porcentagem de ordenação da lista.

A seguir, segue a implementação do código em Python.

\begin{lstlisting}
def selection(V, n):
    for i in range(0, n):
        smallest_num_index = i
        for j in range(i, n):
            if V[j] < V[smallest_num_index]:
                smallest_num_index = j
        V[i], V[smallest_num_index] = V[smallest_num_index], V[i]

\end{lstlisting}

Com o código, percebe-se que, mesmo a lista já estando ordenada, o algoritmo continuará realizando os comandos, ou seja, o número de passagens a ser feita não é mudado devido às condições iniciais de ordenação da lista.
\subsection*{Quantidade de comparações}
Nesta subseção, irá ser debatida a quantidade de comparações feitas pelo algoritmo em questão. Como a quantidade de comparações é "constante" neste algoritmo, será "fácil" de analisá-la; nos outros algoritmos, contudo, a análise é mais compléxa devido à oscilação na quantidade de comparações.

Suponha-se que o algoritmo recebeu uma lista com $n$ elementos. Assim, como não há um dispositivo que pare o código antes, tem-se que, a primeira malha de repetição será executada $n$ vezes, em que a primeira $i=1$, na segunda, $i=2$ e assim por diante. Por consequência, em cada uma dessas execuções, a segunda malha será executada $n-i$ vezes (isto é, na primeira execução, o código contido na segunda malha de repetição será executado $n$ vezes, na segunda, $n-1$, nas seguntes a lógica é análoga.). Dessa forma, o código será executado $n+(n-1)+(n-2)+...+(1)$, ou seja, $\sum_{i=1}^n i = \frac{n(n+1)}{2}$
%TODO ver depois se está correto

Notavelmente, não há variações na quantidade de comparações, ou seja, independente do estado inicial da lista, a forma como o código será executado é a mesma.