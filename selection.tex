\section{Algoritmo de seleção}
O algoritmo de seleção é um algoritmo de ordenação no qual, a cada itineração, o menor elemento da lista é garantido estar na posição correta. Dessa forma, na primeira itineração, assegura-se que o menor elemento ficará na primeira posição da lista, na segunda itineração, o segundo elemento, e assim por diante. 
Uma observação pertinente é que a quantidade de comparações a ser feita independe da porcentagem de ordenação do vetor.

\subsection{Exemplo}
Seja M a lista \code{[4,3,2,1,0]}. Na primeira passagem, o algoritmo detectará o menor elemento da sequência e, logo após, irá permutá-lo com o primeiro elemento da lista, ou seja, o elemento 4 e 0 serão trocados de lugar. Na segunda passagem, começando pelo segundo elemento, a segunda malha de repetição irá detectar o segundo menor elemento e, similarmente, irá permutá-lo com o segundo elemento da lista. Nas próximas execuções, a forma é análoga.

Na n-ésima passagem, onde $n$ é o tamanho da lista, todos os elementos estarão em ordem crescente e, portanto, ordenados.

Assim, seguem as impressões do vetor a cada modificação.

\begin{lstlisting}
[4, 3, 2, 1, 0]
[0, 3, 2, 1, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
\end{lstlisting}

Percebe-se que, mesmo o vetor já estando ordenado, o algoritmo continuará realizando os comandos, ou seja, o número de passagens a serem feitas não é mudado devido às condições iniciais de ordenação.

\newpage
\subsection{Implementação}
A seguir, segue a implementação do código em Python.

\begin{lstlisting}
def selection(V, n):
    for i in range(0, n):
        smallest_num_index = i
        for j in range(i, n):
            if V[j] < V[smallest_num_index]:
                smallest_num_index = j
        V[i], V[smallest_num_index] = V[smallest_num_index], V[i]

\end{lstlisting}
De fato, pelo código percebe-se que não há nenhum mecanismo implementado a fim de detectar a ordenação total da lista e, consequentemente pará-lo.

\subsection{Quantidade de comparações}
Nesta subseção, irá ser debatida a quantidade de comparações feitas pelo algoritmo em questão. Como a quantidade de comparações é independe da ordenação neste algoritmo, será simples de analisá-la; nos outros algoritmos, contudo, a análise é mais complexa devido à oscilação na quantidade de comparações.

Suponha-se que o algoritmo recebeu uma lista com $n$ elementos. Assim, como não há um dispositivo que pare o código antes, tem-se que a primeira malha de repetição será executada $n-i$ vezes, em que o índice inicial $i=0$. Na segunda execução, quando o índice $i=1$, serão realizadas $n-1$ comparações e assim por diante. Por consequência, em cada uma dessas execuções, a segunda malha de repetição (a qual está na primeira) será executada $n-i$ vezes, isto é, o código será executado $n+(n-1)+(n-2)+\cdots+(1) = \sum_{i=1}^n i = \frac{n(n+1)}{2}$ vezes.

Notavelmente, não há variações na quantidade de comparações e, consequentemente, a forma como o código será executado é a mesma independentente do estado inicial da lista.