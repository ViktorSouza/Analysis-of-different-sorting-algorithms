\section{Algoritmo de seleção}
O algoritmo de seleção é um algoritmo de ordenação no qual, a cada itineração, o menor elemento da lista é garantido estar na posição correta. Ou seja, na primeira itineração, assegura-se que o menor elemento ficará na primeira posição da lista, na segunda itineração, o segundo elemento, e assim por diante. 
Uma observação pertinente é que a quantidade de comparações a ser feita independe da porcentagem de ordenação da lista.

\subsection{Exemplo}
Seja M uma lista \code{[4,3,2,1,0]}. Na primeira passagem, o algoritmo detectará o menor elemento da lista e, logo após, irá permutá-lo com o primeiro elemento da lista, ou seja, o elemento 4 e 0 serão trocados de lugar. Na segunda passagem, começando pelo segundo elemento, a segunda malha de repetição irá detectar o segundo menor elemento e, similarmente, irá permutá-lo com o segundo elento da lista. Nas próximas execuções, a forma é análoga.

Na n-ésima passagem, onde $n$ é o tamanho da lista, todos os elementos estarão em ordem crescente e, portanto, ordenados.

Assim, seguem as impressões da lista a cada modificação.

\begin{lstlisting}
[4, 3, 2, 1, 0]
[0, 3, 2, 1, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
[0, 1, 2, 3, 4]
\end{lstlisting}

Percebe-se que, mesmo a lista já estando ordenada, o algoritmo continuará realizando os comandos, ou seja, o número de passagens a ser feita não é mudado devido às condições iniciais de ordenação.

\newpage
\subsection{Implementação}
A seguir, segue a implementação do código em Python.

\begin{lstlisting}
def selection(V, n):
    for i in range(0, n):
        smallest_num_index = i
        for j in range(i, n):
            if V[j] < V[smallest_num_index]:
                smallest_num_index = j
        V[i], V[smallest_num_index] = V[smallest_num_index], V[i]

\end{lstlisting}

\subsection{Quantidade de comparações}
Nesta subseção, irá ser debatida a quantidade de comparações feitas pelo algoritmo em questão. Como a quantidade de comparações é "constante" neste algoritmo, será "fácil" de analisá-la; nos outros algoritmos, contudo, a análise é mais compléxa devido à oscilação na quantidade de comparações.

Suponha-se que o algoritmo recebeu uma lista com $n$ elementos. Assim, como não há um dispositivo que pare o código antes, tem-se que a primeira malha de repetição será executada $n$ vezes, em que o índice inicial $i=1$, na segunda, quando o índice $i=2$ e assim por diante. Por consequência, em cada uma dessas execuções, a segunda malha (que está dentro da primeira) será executada $n-i$ vezes, ou seja, na primeira execução, o código contido na segunda malha de repetição será executado $n$ vezes, na segunda, $n-1$, e assim por diante. Dessa forma, o código será executado $n+(n-1)+(n-2)+\cdots+(1)$, ou seja, $\sum_{i=1}^n i = \frac{n(n+1)}{2}$

Notavelmente, não há variações na quantidade de comparações, ou seja, independente do estado inicial da lista, a forma como o código será executado é a mesma.