\section{Implementação em C}
Nesta seção, implementaram-se, na linguagem C, os algoritmos em tópico a fim de analisar os impactos no desempenho quando executado um algoritmo em uma linguagem compilada, tal como o C.
Após visto o comportamento dos algoritmos em Python, uma linguagem interpretada, percebe-se que, mesmo para vetores com poucos elementos, o tempo gasto para ordená-los é significativo.

Quando implementados utilizando a linguagem C, contudo, nota-se uma considerável redução na duração dos testes, uma vez que, em razão do C ser uma linguagem compilada, as malhas de repetição tendem a ser mais eficientes.
Ademais, ao utilizar a linguagem C, há um maior controle na forma como o código será executado, devido ao C ser uma linguagem com um nível mais baixo e tipada, em outras palavras, há uma possibilidade de otimizar o código de maneira mais eficaz.


Dessa forma, serão analisados os desempenhos dos algoritmos já implementados em Python, mas, desta vez, estes serão escritos na linguagem C.
A fim de realizar o testes, os algoritmos foram implementados na linguagem C, utilizando, como referência, os códigos já escritos em Python. Sendo assim, tendo em vista que os códigos utilizandos em C não foram otimizados e nem modificados de forma a deixá-los mais rápidos ou lentos, ter-se-á uma comparação equânime.
Além disso, as funções foram invocadas no Python visando criar os gráficos dos resultados.

Por fim, é necessário ressaltar que foram realizados somentes testes visando analisar o comportamento dos algoritmos em C quando estes são submetidos a sequências com tamanhos variáveis, ou seja, o segundo teste não será executado, pois serão obtidos resultados similares ao anterior.

\newpage
\subsection{Resultados}
A seguir, serão analisados os resultados encontrados, assim como no primeiro teste, realizando a execução dos algoritmos implementados em C e, para fins comparativos, do algoritmo contagem cuja realização foi feita na linguagem principal.
\begin{figure}[h]
    \includegraphics[width=8cm]{c sizes.png}
    \caption{Gráfico ilustrando o tempo médio de execução dos algoritmos implementados em C comparado ao do contagem, implementado em Python.}
\end{figure}
\def\arraystretch{1.5}
\setlength\arrayrulewidth{0.3pt}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|F|F|F|F|F|}
        \hline
        \multicolumn{2}{|l|}{\textbf{Elementos} }& \textbf{1000} & \textbf{5000} & \textbf{10000} & \textbf{50000} & \textbf{100000} \\
        \hline
        \multirow{2}{*}{\textbf{\shortstack{Contagem\\(Python)}}}&
        \textbf{Tempo} & 0.2798 & 1.3991 & 2.5873 & 13.1278 & 25.9120 \\
        \cline{2-7}
        &$\sigma$ & 0.001368 & 0.041076 & 0.000821 & 0.068934 & 0.019201 \\
        \hline
        
        \multirow{2}{*}{\textbf{Contagem}}&
        \textbf{Tempo} & 0.0221 & 0.1099 & 0.2151 & 1.0672 & 2.1320 \\
 \cline{2-7}
        &$\sigma$ & 0.000001 & 0.000023 & 0.000006 & 0.000065 & 0.000073 \\
        \hline
        \multirow{2}{*}{\textbf{Bolha}}& \textbf{Tempo} & 0.0222 & 0.1088 & 0.2136 & 1.0653 & 2.1423 \\
        \cline{2-7}
        & $\sigma$ & 0.000002 & 0.000003 & 0.000007 & 0.000035 & 0.002216 \\
        \hline
        \multirow{2}{*}{\textbf{Seleção}}& \textbf{Tempo} & 0.0219 & 0.1091 & 0.2151 & 1.0638 & 2.1244 \\
                \cline{2-7}
        &$\sigma$ & 0.0000001 & 0.000002 & 0.000017 & 0.000022 & 0.000139 \\
        \hline
        \multirow{2}{*}{\textbf{Inserção}} &\textbf{Tempo} & 0.0220 & 0.1064 & 0.2147 & 1.0609 & 2.1281 \\
        \cline{2-7}
        & $\sigma$ & 0.0000004 & 0.000003 & 0.000010 & 0.000053 & 0.000056 \\
        \hline
    \end{tabular}
    \caption{Tempos de execução e desvios-padrões dos algoritmos de ordenação (em segundos) para diferentes tamanhos de lista}
    \label{tab:tempos_desvios_ordenacao_transposta}
\end{table}
\newpage

%TODO melhorar este texto
De início, nota-se que o comportamento dos algoritmos não é modificado, isto é, permaneceram inalteradas, quando implementados em C, características como a maior oscilação (maior desvio-padrão) no tempo dos algoritmos que variam dependendo da taxa de ordenação inicial.
Assim, o comportamento esperado dos algoritmos ainda é visível, independente da linguagem utilizada na implementação.


Ademais, o ganho de desempenho dos algoritmos implementados em C mos-\linebreak trou-se singificativo; mesmo os mais lentos quando implementados em Python, como o bolha, obtiveram uma performance superior ao contagem da linguagem inicial.
Por outro lado, não houve uma mudança perceptível nos desvios-padrões de cada algoritmo, em outras palavras, a oscilação no tempo necessário em cada algoritmo permaneceu semelhante na implementação em ambas as linguagens.


De fato, o contagem implementado em Python foi, aproximadamente, 12 vezes mais lento que a sua versão em C quando executado utilizando listas com 100000 elementos. Em listas com tamanhos menores, essa diferença manteu-se quase constante, oscilando entre 12 e 13 vezes mais demorado, em outros termos, não há uma alteração significante no desempenho em relação à grandeza do vetor se comparada a implementação em ambas as linguagens. Dessa maneira, é notável que a implementação em C mostrou-se mais eficaz, independente do tamanho da lista.

Por outro lado, se comparados os algoritmos que utilizam comparações para realizar o arranjo, o ganho de desempenho adquirido é maior: o bolha em C, na ordenação de 100000 elementos, foi 370 vezes mais rápido que a sua implementação em Python. Por consequência, percebe-se que algoritmos que dependem de intensas comparações são mais eficazes em C.


Portanto, visando um ganho de performance, é recomendável a utilização da linguagem C a fim de implementar algoritmos que se beneficiam de malhas de repetições.
Ademais, caso seja necessário o uso do Python para outras tarefas no projeto, as funções em C podem ser chamadas por meio da criação de bibliotecas e, por meio destas, importá-las no Python.