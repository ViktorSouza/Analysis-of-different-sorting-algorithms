\documentclass[10pt,a4paper]{article}
\setlength{\parskip}{\baselineskip}%
% \setlength{\parindent}{0pt}%
\usepackage{indentfirst}
% \usepackage{minted}
% \usemintedstyle{manni}
\usepackage{listings}


\usepackage{xcolor} % for setting colors
\usepackage[most]{tcolorbox}




\lstset{%
  language=python,
  commentstyle=\bfseries,
  escapeinside={(*@}{@*)}
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codecyan}{rgb}{0.2, 0.4, 0.7}
\definecolor{backcolour}{rgb}{0.96,0.96,0.98}
\definecolor{dark}{rgb}{0.3,0.3,0.3}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    rulecolor=\color{backcolour},
    commentstyle=\color{codegreen},
    framexleftmargin=3mm,
     framextopmargin=1mm,
     framexbottommargin=1mm,
    keywordstyle=\color{codecyan},
    identifierstyle = \color[rgb]{0.0,0.4,0.4},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codecyan},
    basicstyle=\ttfamily\color{dark},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,           
    frame=single,
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
}
\lstset{style=mystyle}
% \usepackage{pythonhighlight}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{graphicx}

\usepackage{amsfonts}
\usepackage{amssymb}
\graphicspath{ {./plots/} }
\author{João Viktor Souza Almeida}
\title{Análise de diferentes algoritmos de ordenação}



\begin{document}
\begin{titlepage} %iniciando a "capa"
    \begin{center} %centralizar o texto abaixo
    {\large Universidade de São Paulo}\\[0.2cm] %0,2cm é a distância entre o texto dessa linha e o texto da próxima
    {\large Instituto de Matemática e Estatística}\\[0.2cm] % o comando \\ "manda" o texto ir para próxima linha
    {\large Departamento de Ciência da Computação}\\[0.2cm]
    {\large Bacharelado em Ciência da Computação}\\[0.2cm]
    {\large MAC110 - Introdução à Computação}\\[5.1cm]
    {\bf \huge Análise de diferentes algoritmos de ordenação}\\[5.1cm] 
    \end{center} %término do comando centralizar
    {\large Aluno(a): João Viktor Souza Almeida}\\[0.7cm] % o comando \large deixa o texto grande
    {\large Professor: Roberto Hirata Junior}\\[5.1cm]
    \end{titlepage} %término da "capa"

\subsection*{Resumo}
O relatório a seguir visa analisar "alguns" algoritmos de ordenação e como suas eficiências mudam dadas diferentes condições iniciais, tais como porcentagem de ordenação e número de elementos da lista a ser ordenada. 
\
\section*{Metodologia}
Na criação do relatório, os testes dos algoritmos foram realizados utilizando a linguagem de programação Python com a versão 3.10.11. Durante a execução dos algoritmos, foi utilizada uma máquina com as seguintes configurações:
\begin{itemize}
\item    Processador (CPU): Ryzen 5 3350G 
\item Memória (RAM): 16GB DDR4 @ 3200MHz
\item Armazenamento: 256GB SSD
\item Placa de Vídeo (GPU): Radeon Vega 11
\item Sistema Operacional: Windows 11 Pro
\end{itemize}
Além disso, durante a execução dos algoritmos, foram desabilitados o máximo de programas possíveis a fim de minimizar as interferências nos resutlados dos testes. 

Para computar a média de execução, foi invocada uma função \textit{timeMe}, na qual eram armazenados os resultados das 10 itinerações do mesmo algoritmo e, no final, retornava a média e o desvio padrão dos resultados.

Para fins simplificatórios, foram ignorados possíveis margens de erros da função que retorna a lista embaralhada. Contudo, essa margem de erro torna-se inotável durante os testes devido ao tamanho das listas utilizadas.
\subsection{Testes}
    Para a realização do relatório, foram realizados dois testes. 
    
    O primeiro focou em observar os impactos causados pelo tamanho da lista a ser ordenada, ou seja, como o desvio padrão e a média mudam ao aumentar ou diminuir o tamanho da lista a ser ordenada por cada algoritmo. 
    Para isso, foi criada uma malha de repetição e computados as médias e os devios-padrões de cada algoritmo com listas de tamanhos 1000, 5000, 10000, 50000 e 100000.
    
    O segundo, por outro lado, buscou elucidar acerca das mudanças causadas pela taxa de ordenação de uma lista.
    Para isso, foi estabelecida uma segunda malha de repetição, na qual também foi computada as médias e os devios-padrçoes de cada algoritmo, mas com uma lista de 100000 elementos e com porcentagens de ordenação de 1\%, 3\%, 5\%, 10\% e 50\%.
    

    Para computar a média, foi criada uma função cujos parâmetros são uma lista e o tamanho desta, respectivamente. O desvio padrão, por outro lado, foi calculado por meio de uma função que recebe os mesmos parâmetros que a função outrora citada.
    

\noindent\textbf{Palavras-chave:} insertion, bubble, counting, selection, algoritmos, ordenação, análise;

\newpage
\tableofcontents
\include{selection.tex}
\include{bubble.tex}
\include{insertion.tex}
\include{count.tex}

\section{Comparações}

Como supracitado, o algoritmo de bolha e o de inserção variam de acordo com a taxa de ordenação. Assim, em caso de ordenação total, ambos os algoritmos adquirem um comportamento linear.
\begin{figure}[h]
    \includegraphics[width=8cm]{sizes.png}
    \caption{Gráfico elucidando o comportamento de cada algoritmo em tópico}
    \end{figure}



\section*{Conclusão}
Os algoritmos em questão, apesar de possuírem diferentes desempenhos dependendo da ordenação da lista, possuem um baixo proveito com listas muito grande. Portanto, a fim de ordenar uma lista com maior rapidez, é notável que a função built-in do Python deve, pelo menos para listas grandes, ser usada em relação aos outros métodos outrora discutidos.

\end{document}